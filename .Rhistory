ReturnsBeta0Par = fdPar(ReturnsBetaBasis, 2, 1e-10)
ReturnsBeta1fd  = bifd(matrix(0,23,23), ReturnsBetaBasis, ReturnsBetaBasis)
ReturnsBeta1Par = bifdPar(ReturnsBeta1fd, 2, 2, 1e3, 1e3)
ReturnsBetaList = list(ReturnsBeta0Par, ReturnsBeta1Par)
#  Define the response and explanatory vars
NextYear = EquityReturnsMatfd[2:ncol(EquityReturnsMat)] # Y(t)
LastYear = EquityReturnsMatfd[1:(ncol(EquityReturnsMat)-1)] # X(t)
Returns.linmod = linmod(NextYear, LastYear, ReturnsBetaList)
Returns.times = seq(0, 39, 1)
Returns.beta1mat = eval.bifd(Returns.times, Returns.times, Returns.linmod$beta1estbifd)
persp(Returns.times, Returns.times, Returns.beta1mat,
xlab="time", ylab="time",zlab="beta(s,t)",
cex.lab=1.5,cex.axis=1.5)
# predict next year
last_year = EquityReturnsMat[,ncol(EquityReturnsMat)]
lastYearNew <- smooth.basis(ReturnsDayRng,last_year,ReturnsBasis)
# number of time points in a day (10 minute intervals over trading hours)
nbasis = 41
norder = 4
ReturnsDayTime = 0:39;
ReturnsDayRng = c(1,40);
ReturnsBasis = create.bspline.basis(ReturnsDayRng, nbasis, norder)
D2fdPar = fdPar(ReturnsBasis, lambda=0.0001)
EquityReturnsMatfd = smooth.basis(ReturnsDayTime, EquityReturnsMat, D2fdPar)$fd
nbasis_regression = 23
ReturnsRng = c(0,39)
ReturnsBetaBasis = create.bspline.basis(ReturnsRng,nbasis_regression, norder=4)
ReturnsBeta0Par = fdPar(ReturnsBetaBasis, 2, 1e-10)
ReturnsBeta1fd  = bifd(matrix(0,23,23), ReturnsBetaBasis, ReturnsBetaBasis)
ReturnsBeta1Par = bifdPar(ReturnsBeta1fd, 2, 2, 1e3, 1e3)
ReturnsBetaList = list(ReturnsBeta0Par, ReturnsBeta1Par)
#  Define the response and explanatory vars
NextYear = EquityReturnsMatfd[2:ncol(EquityReturnsMat)] # Y(t)
LastYear = EquityReturnsMatfd[1:(ncol(EquityReturnsMat)-1)] # X(t)
Returns.linmod = linmod(NextYear, LastYear, ReturnsBetaList)
Returns.times = seq(0, 39, 1)
Returns.beta1mat = eval.bifd(Returns.times, Returns.times, Returns.linmod$beta1estbifd)
persp(Returns.times, Returns.times, Returns.beta1mat,
xlab="time", ylab="time",zlab="beta(s,t)",
cex.lab=1.5,cex.axis=1.5)
# predict next year
last_year = EquityReturnsMat[,ncol(EquityReturnsMat)]
lastYearNew <- smooth.basis(ReturnsDayRng,last_year,ReturnsBasis)
lastYearNew <- lastYearNew$fd
lastYearmat <- eval.fd(c(0:39), lastYearNew)
# calculate integral of beta1(s,t)*x_i(t) using inner product
dim(Returns.beta1mat)
dim(lastYearmat)
integral_estimate <-  Returns.beta1mat %*% lastYearmat
# add beta_0 to integral estimate
Returns.beta0 = eval.fd(Returns.times, Returns.linmod$beta0estfd)
dim(integral_estimate)
dim(Returns.beta0)
function_output <- Returns.beta0 + integral_estimate
plot(EquityReturnsMatfd)
plot(function_output, type="l")
library(fda)
library(tidyverse)
equity_returns_matrix_name = "2020_SPY_returns_2020-08-01_2020-10-01_matrix"
# data processing
mat =load(paste("ProcessedRData/", equity_returns_matrix_name, ".RData", sep=""))
mat=as.matrix(returns_matrix)
T_stationary(returns_matrix)
dim(returns_matrix)
EquityReturnsMat = as.matrix(returns_matrix)
# number of time points in a day (10 minute intervals over trading hours)
nbasis = 40
norder = 4
ReturnsDayTime = 0:39;
ReturnsDayRng = c(0,39);
ReturnsBasis = create.bspline.basis(ReturnsDayRng, nbasis, norder)
D2fdPar = fdPar(ReturnsBasis, lambda=0.0001)
EquityReturnsMatfd = smooth.basis(ReturnsDayTime, EquityReturnsMat, D2fdPar)$fd
nbasis_regression = 23
ReturnsRng = c(0,39)
ReturnsBetaBasis = create.bspline.basis(ReturnsRng,nbasis_regression, norder=4)
ReturnsBeta0Par = fdPar(ReturnsBetaBasis, 2, 1e-10)
ReturnsBeta1fd  = bifd(matrix(0,23,23), ReturnsBetaBasis, ReturnsBetaBasis)
ReturnsBeta1Par = bifdPar(ReturnsBeta1fd, 2, 2, 1e3, 1e3)
ReturnsBetaList = list(ReturnsBeta0Par, ReturnsBeta1Par)
#  Define the response and explanatory vars
NextYear = EquityReturnsMatfd[2:ncol(EquityReturnsMat)] # Y(t)
LastYear = EquityReturnsMatfd[1:(ncol(EquityReturnsMat)-1)] # X(t)
Returns.linmod = linmod(NextYear, LastYear, ReturnsBetaList)
Returns.times = seq(0, 39, 1)
Returns.beta1mat = eval.bifd(Returns.times, Returns.times, Returns.linmod$beta1estbifd)
persp(Returns.times, Returns.times, Returns.beta1mat,
xlab="time", ylab="time",zlab="beta(s,t)",
cex.lab=1.5,cex.axis=1.5)
# predict next year
last_year = EquityReturnsMat[,ncol(EquityReturnsMat)]
lastYearNew <- smooth.basis(ReturnsDayRng,last_year,ReturnsBasis)
# predict next year
last_year = EquityReturnsMatfd[,ncol(EquityReturnsMat)]
lastYearNew <- smooth.basis(ReturnsDayRng,last_year,ReturnsBasis)
# predict next year
last_year = EquityReturnsMat[,ncol(EquityReturnsMat)]
lastYearNew <- smooth.basis(ReturnsDayRng,last_year,ReturnsBasis)
lastYearNew <- smooth.basis(c(0:39),last_year,ReturnsBasis)
lastYearNew <- smooth.basis(c(0:39),last_year,ReturnsBasis)
lastYearNew <- lastYearNew$fd
lastYearmat <- eval.fd(c(0:39), lastYearNew)
# calculate integral of beta1(s,t)*x_i(t) using inner product
dim(Returns.beta1mat)
dim(lastYearmat)
integral_estimate <-  Returns.beta1mat %*% lastYearmat
# add beta_0 to integral estimate
Returns.beta0 = eval.fd(Returns.times, Returns.linmod$beta0estfd)
dim(integral_estimate)
dim(Returns.beta0)
function_output <- Returns.beta0 + integral_estimate
plot(EquityReturnsMatfd)
plot(function_output, type="l")
plot(EquityReturnsMatfd)
save_returns_data_matrix(fileName="2020_SPY_returns_2020-08-03_2020-09-30.csv")
save_returns_data_matrix <- function(fileName) {
df = read.csv(paste("ProcessedCSVData/", fileName, sep=""), stringsAsFactors = FALSE)
df$returns <- as.numeric(df$returns)
summary(df)
any(is.na(df))
matplot(df$returns, type="l")
df$TimeStamp <- ymd_hms(df$TimeStamp)
df$Date <- as.Date(df$TimeStamp)
df$Time <- format(df$TimeStamp, "%H:%M:%S")
returns_matrix = matrix(0, length(unique(df$Time)), length(unique(df$Date)))
# iterate over each day
for (i in 1:ncol(returns_matrix)) {
# iterate over each 10-minute interval
for (j in 1:nrow(returns_matrix)) {
returns_matrix[j, i] <- df$returns[(i-1)*nrow(returns_matrix) + j]
}
}
matplot(returns_matrix, type="l")
dimnames(returns_matrix)[[2]] <- paste('b', unique(df$Date), sep='')
save(returns_matrix, file=paste("ProcessedRData/", sub('\\.csv$', '', fileName), "_matrix.RData", sep=""))
}
save_returns_data_matrix(fileName="2020_SPY_returns_2020-08-03_2020-09-30.csv")
library(fda)
library(tidyverse)
equity_returns_matrix_name = "2020_SPY_returns_2020-08-03_2020-09-30_matrix"
# data processing
mat =load(paste("ProcessedRData/", equity_returns_matrix_name, ".RData", sep=""))
mat=as.matrix(returns_matrix)
library(fda)
library(tidyverse)
library(ftsa)
equity_returns_matrix_name = "2020_SPY_returns_2020-08-03_2020-09-30_matrix"
# data processing
mat =load(paste("ProcessedRData/", equity_returns_matrix_name, ".RData", sep=""))
mat=as.matrix(returns_matrix)
dim(returns_matrix)
EquityReturnsMat = as.matrix(returns_matrix)
T_stationary(EquityReturnsMat)
# number of time points in a day (10 minute intervals over trading hours)
nbasis = 40
norder = 4
ReturnsDayTime = 0:39;
ReturnsDayRng = c(0,39);
ReturnsBasis = create.bspline.basis(ReturnsDayRng, nbasis, norder)
D2fdPar = fdPar(ReturnsBasis, lambda=0.0001)
EquityReturnsMatfd = smooth.basis(ReturnsDayTime, EquityReturnsMat, D2fdPar)$fd
nbasis_regression = 23
ReturnsRng = c(0,39)
ReturnsBetaBasis = create.bspline.basis(ReturnsRng,nbasis_regression, norder=4)
ReturnsBeta0Par = fdPar(ReturnsBetaBasis, 2, 1e-10)
ReturnsBeta1fd  = bifd(matrix(0,23,23), ReturnsBetaBasis, ReturnsBetaBasis)
ReturnsBeta1Par = bifdPar(ReturnsBeta1fd, 2, 2, 1e3, 1e3)
ReturnsBetaList = list(ReturnsBeta0Par, ReturnsBeta1Par)
library(fda)
library(tidyverse)
library(ftsa)
equity_returns_matrix_name = "2020_SPY_returns_2020-08-03_2020-09-30_matrix"
# data processing
mat =load(paste("ProcessedRData/", equity_returns_matrix_name, ".RData", sep=""))
mat=as.matrix(returns_matrix)
dim(returns_matrix)
EquityReturnsMat = as.matrix(returns_matrix)
T_stationary(EquityReturnsMat)
# number of time points in a day (10 minute intervals over trading hours)
nbasis = 40
norder = 4
ReturnsDayTime = 0:39;
ReturnsDayRng = c(0,39);
ReturnsBasis = create.bspline.basis(ReturnsDayRng, nbasis, norder)
D2fdPar = fdPar(ReturnsBasis, lambda=0.0001)
EquityReturnsMatfd = smooth.basis(ReturnsDayTime, EquityReturnsMat, D2fdPar)$fd
nbasis_regression = 23
ReturnsRng = c(0,39)
ReturnsBetaBasis = create.bspline.basis(ReturnsRng,nbasis_regression, norder=4)
ReturnsBeta0Par = fdPar(ReturnsBetaBasis, 2, 1e-10)
ReturnsBeta1fd  = bifd(matrix(0,23,23), ReturnsBetaBasis, ReturnsBetaBasis)
ReturnsBeta1Par = bifdPar(ReturnsBeta1fd, 2, 2, 1e3, 1e3)
ReturnsBetaList = list(ReturnsBeta0Par, ReturnsBeta1Par)
#  Define the response and explanatory vars
NextYear = EquityReturnsMatfd[2:ncol(EquityReturnsMat)] # Y(t)
LastYear = EquityReturnsMatfd[1:(ncol(EquityReturnsMat)-1)] # X(t)
Returns.linmod = linmod(NextYear, LastYear, ReturnsBetaList)
Returns.times = seq(0, 39, 1)
Returns.beta1mat = eval.bifd(Returns.times, Returns.times, Returns.linmod$beta1estbifd)
persp(Returns.times, Returns.times, Returns.beta1mat,
xlab="time", ylab="time",zlab="beta(s,t)",
cex.lab=1.5,cex.axis=1.5)
# predict next year
last_year = EquityReturnsMat[,ncol(EquityReturnsMat)]
lastYearNew <- smooth.basis(c(0:39),last_year,ReturnsBasis)
lastYearNew <- lastYearNew$fd
lastYearmat <- eval.fd(c(0:39), lastYearNew)
# estimate integral of beta1(s,t)*x_i(t) using inner product
dim(Returns.beta1mat)
dim(lastYearmat)
integral_estimate <-  Returns.beta1mat %*% lastYearmat
# add beta_0 to integral estimate
Returns.beta0 = eval.fd(Returns.times, Returns.linmod$beta0estfd)
dim(integral_estimate)
dim(Returns.beta0)
function_output <- Returns.beta0 + integral_estimate
plot(EquityReturnsMatfd)
plot(function_output, type="l")
plot(EquityReturnsMatfd)
plot(function_output, type="l")
T_stationary(EquityReturnsMat$fd)
library(fda)
library(tidyverse)
equity_returns_matrix_name = "2020_SPY_returns_2020-08-03_2020-09-30_matrix"
# data processing
mat =load(paste("ProcessedRData/", equity_returns_matrix_name, ".RData", sep=""))
mat=as.matrix(returns_matrix)
dim(returns_matrix)
EquityReturnsMat = as.matrix(returns_matrix)
# number of time points in a day (10 minute intervals over trading hours)
nbasis = 40
norder = 4
ReturnsDayTime = 0:39;
ReturnsDayRng = c(0,39);
ReturnsBasis = create.bspline.basis(ReturnsDayRng, nbasis, norder)
D2fdPar = fdPar(ReturnsBasis, lambda=0.0001)
EquityReturnsMatfd = smooth.basis(ReturnsDayTime, EquityReturnsMat, D2fdPar)$fd
nbasis_regression = 23
ReturnsRng = c(0,39)
ReturnsBetaBasis = create.bspline.basis(ReturnsRng,nbasis_regression, norder=4)
ReturnsBeta0Par = fdPar(ReturnsBetaBasis, 2, 1e-10)
ReturnsBeta1fd  = bifd(matrix(0,23,23), ReturnsBetaBasis, ReturnsBetaBasis)
ReturnsBeta1Par = bifdPar(ReturnsBeta1fd, 2, 2, 1e3, 1e3)
ReturnsBetaList = list(ReturnsBeta0Par, ReturnsBeta1Par)
#  Define the response and explanatory vars
NextYear = EquityReturnsMatfd[2:ncol(EquityReturnsMat)] # Y(t)
LastYear = EquityReturnsMatfd[1:(ncol(EquityReturnsMat)-1)] # X(t)
Returns.linmod = linmod(NextYear, LastYear, ReturnsBetaList)
Returns.times = seq(0, 39, 1)
Returns.beta1mat = eval.bifd(Returns.times, Returns.times, Returns.linmod$beta1estbifd)
persp(Returns.times, Returns.times, Returns.beta1mat,
xlab="time", ylab="time",zlab="beta(s,t)",
cex.lab=1.5,cex.axis=1.5)
# predict next year
last_year = EquityReturnsMat[,ncol(EquityReturnsMat)]
lastYearNew <- smooth.basis(c(0:39),last_year,ReturnsBasis)
lastYearNew <- lastYearNew$fd
lastYearmat <- eval.fd(c(0:39), lastYearNew)
# estimate integral of beta1(s,t)*x_i(t) using inner product
dim(Returns.beta1mat)
dim(lastYearmat)
integral_estimate <-  Returns.beta1mat %*% lastYearmat
# add beta_0 to integral estimate
Returns.beta0 = eval.fd(Returns.times, Returns.linmod$beta0estfd)
dim(integral_estimate)
dim(Returns.beta0)
function_output <- Returns.beta0 + integral_estimate
plot(EquityReturnsMatfd)
plot(function_output, type="l")
mat=load("/Users/raunaksandhu/Desktop/UNI/4th YR/Winter/MATH 518/RCode/Testing/Sweden.Rdata")
mat=as.matrix(SwedeMat)
matplot(mat,type="l")
SwedeMat = mat
dim(SwedeMat)
SwedeLogHazard = as.matrix(SwedeMat)
dimnames(SwedeLogHazard)[[2]] <- paste('b', 1751:1894, sep='')
Fig10.10data = cbind(SwedeLogHazard[, c('b1751', 'b1810', 'b1860')],
Swede1920)
SwedeTime = 0:80;
SwedeRng = c(0,80);
library(fda)
mat=load("/Users/raunaksandhu/Desktop/UNI/4th YR/Winter/MATH 518/RCode/Testing/Sweden.Rdata")
mat=as.matrix(SwedeMat)
matplot(mat,type="l")
SwedeMat = mat
dim(SwedeMat)
SwedeLogHazard = as.matrix(SwedeMat)
dimnames(SwedeLogHazard)[[2]] <- paste('b', 1751:1894, sep='')
Fig10.10data = cbind(SwedeLogHazard[, c('b1751', 'b1810', 'b1860')],
Swede1920)
SwedeTime = 0:80;
SwedeRng = c(0,80);
matplot(SwedeTime, Fig10.10data,
type='l',lwd=2,xlab='age',ylab='log Hazard',col=1,
cex.lab=1.5,cex.axis=1.5)
nbasis = 75
norder = 6
SwedeBasis = create.bspline.basis(SwedeRng, nbasis, norder)
D2fdPar = fdPar(SwedeBasis, lambda=1e-7)
SwedeLogHazfd = smooth.basis(SwedeTime, SwedeLogHazard, D2fdPar)$fd
nbasis     = 23
SwedeRng   = c(0,80)
SwedeBetaBasis = create.bspline.basis(SwedeRng,nbasis)
SwedeBeta0Par = fdPar(SwedeBetaBasis, 2, 1e-5)
SwedeBeta1fd  = bifd(matrix(0,23,23), SwedeBetaBasis, SwedeBetaBasis)
SwedeBeta1Par = bifdPar(SwedeBeta1fd, 2, 2, 1e3, 1e3)
SwedeBetaList = list(SwedeBeta0Par, SwedeBeta1Par)
NextYear = SwedeLogHazfd[2:144]
LastYear = SwedeLogHazfd[1:143]
Swede.linmod = linmod(NextYear, LastYear, SwedeBetaList)
Swede.ages = seq(0, 80, 1)
Swede.beta1mat = eval.bifd(Swede.ages, Swede.ages, Swede.linmod$beta1estbifd)
quartz()
persp(Swede.ages, Swede.ages, Swede.beta1mat,
xlab="age", ylab="age",zlab="beta(s,t)",
cex.lab=1.5,cex.axis=1.5)
# predict next year
last_year = SwedeLogHazard[,144]
lastYearNew <- smooth.basis(c(0:80),last_year,SwedeBasis)
lastYearNew <- lastYearNew$fd
lastYearmat <- eval.fd(c(0:80), lastYearNew)
# calculate integral of beta1(s,t)*x_i(t)
dim(Swede.beta1mat)
dim(lastYearmat)
integral_estimate <-  Swede.beta1mat %*% lastYearmat
# add beta_0 to integral estimate
Swede.beta0 = eval.fd(SwedeTime, Swede.linmod$beta0estfd)
dim(integral_estimate)
dim(Swede.beta0)
function_output <- Swede.beta0 + integral_estimate
plot(SwedeLogHazfd)
lines(function_output, type="l")
matplot(SwedeTime, Fig10.10data,
type='l',lwd=2,xlab='age',ylab='log Hazard',col=1,
cex.lab=1.5,cex.axis=1.5)
library(fda)
mat=load("/Users/raunaksandhu/Desktop/UNI/4th YR/Winter/MATH 518/RCode/Testing/Sweden.Rdata")
mat=as.matrix(SwedeMat)
matplot(mat,type="l")
SwedeMat = mat
dim(SwedeMat)
SwedeLogHazard = as.matrix(SwedeMat)
dimnames(SwedeLogHazard)[[2]] <- paste('b', 1751:1894, sep='')
Fig10.10data = cbind(SwedeLogHazard[, c('b1751', 'b1810', 'b1860')],
Swede1920)
SwedeTime = 0:80;
SwedeRng = c(0,80);
matplot(SwedeTime, Fig10.10data,
type='l',lwd=2,xlab='age',ylab='log Hazard',col=1,
cex.lab=1.5,cex.axis=1.5)
nbasis = 75
norder = 6
SwedeBasis = create.bspline.basis(SwedeRng, nbasis, norder)
D2fdPar = fdPar(SwedeBasis, lambda=1e-7)
SwedeLogHazfd = smooth.basis(SwedeTime, SwedeLogHazard, D2fdPar)$fd
nbasis     = 23
SwedeRng   = c(0,80)
SwedeBetaBasis = create.bspline.basis(SwedeRng,nbasis)
SwedeBeta0Par = fdPar(SwedeBetaBasis, 2, 1e-5)
SwedeBeta1fd  = bifd(matrix(0,23,23), SwedeBetaBasis, SwedeBetaBasis)
SwedeBeta1Par = bifdPar(SwedeBeta1fd, 2, 2, 1e3, 1e3)
SwedeBetaList = list(SwedeBeta0Par, SwedeBeta1Par)
NextYear = SwedeLogHazfd[2:144]
LastYear = SwedeLogHazfd[1:143]
Swede.linmod = linmod(NextYear, LastYear, SwedeBetaList)
Swede.ages = seq(0, 80, 1)
Swede.beta1mat = eval.bifd(Swede.ages, Swede.ages, Swede.linmod$beta1estbifd)
quartz()
persp(Swede.ages, Swede.ages, Swede.beta1mat,
xlab="age", ylab="age",zlab="beta(s,t)",
cex.lab=1.5,cex.axis=1.5)
# predict next year
last_year = SwedeLogHazard[,144]
lastYearNew <- smooth.basis(c(0:80),last_year,SwedeBasis)
lastYearNew <- lastYearNew$fd
lastYearmat <- eval.fd(c(0:80), lastYearNew)
# calculate integral of beta1(s,t)*x_i(t)
dim(Swede.beta1mat)
dim(lastYearmat)
integral_estimate <-  Swede.beta1mat %*% lastYearmat
# add beta_0 to integral estimate
Swede.beta0 = eval.fd(SwedeTime, Swede.linmod$beta0estfd)
dim(integral_estimate)
dim(Swede.beta0)
function_output <- Swede.beta0 + integral_estimate
plot(SwedeLogHazfd)
lines(function_output, type="l")
library(fda)
mat=load("/Users/raunaksandhu/Desktop/UNI/4th YR/Winter/MATH 518/RCode/Testing/Sweden.Rdata")
mat=as.matrix(SwedeMat)
matplot(mat,type="l")
dev.off()
matplot(mat,type="l")
matplot(mat,type="l")
SwedeMat = mat
dim(SwedeMat)
SwedeLogHazard = as.matrix(SwedeMat)
dimnames(SwedeLogHazard)[[2]] <- paste('b', 1751:1894, sep='')
Fig10.10data = cbind(SwedeLogHazard[, c('b1751', 'b1810', 'b1860')],
Swede1920)
SwedeTime = 0:80;
dev.new()
matplot(mat,type="l")
mat=load("/Users/raunaksandhu/Desktop/UNI/4th YR/Winter/MATH 518/RCode/Testing/Sweden.Rdata")
mat=as.matrix(SwedeMat)
dev.new()
matplot(mat,type="l")
SwedeMat = mat
dim(SwedeMat)
SwedeLogHazard = as.matrix(SwedeMat)
dimnames(SwedeLogHazard)[[2]] <- paste('b', 1751:1894, sep='')
Fig10.10data = cbind(SwedeLogHazard[, c('b1751', 'b1810', 'b1860')],
Swede1920)
SwedeTime = 0:80;
SwedeRng = c(0,80);
matplot(SwedeTime, Fig10.10data,
type='l',lwd=2,xlab='age',ylab='log Hazard',col=1,
cex.lab=1.5,cex.axis=1.5)
nbasis = 75
norder = 6
SwedeBasis = create.bspline.basis(SwedeRng, nbasis, norder)
D2fdPar = fdPar(SwedeBasis, lambda=1e-7)
SwedeLogHazfd = smooth.basis(SwedeTime, SwedeLogHazard, D2fdPar)$fd
nbasis     = 23
SwedeRng   = c(0,80)
SwedeBetaBasis = create.bspline.basis(SwedeRng,nbasis)
SwedeBeta0Par = fdPar(SwedeBetaBasis, 2, 1e-5)
SwedeBeta1fd  = bifd(matrix(0,23,23), SwedeBetaBasis, SwedeBetaBasis)
SwedeBeta1Par = bifdPar(SwedeBeta1fd, 2, 2, 1e3, 1e3)
SwedeBetaList = list(SwedeBeta0Par, SwedeBeta1Par)
NextYear = SwedeLogHazfd[2:144]
LastYear = SwedeLogHazfd[1:143]
Swede.linmod = linmod(NextYear, LastYear, SwedeBetaList)
Swede.ages = seq(0, 80, 1)
Swede.beta1mat = eval.bifd(Swede.ages, Swede.ages, Swede.linmod$beta1estbifd)
persp(Swede.ages, Swede.ages, Swede.beta1mat,
xlab="age", ylab="age",zlab="beta(s,t)",
cex.lab=1.5,cex.axis=1.5)
# predict next year
last_year = SwedeLogHazard[,144]
lastYearNew <- smooth.basis(c(0:80),last_year,SwedeBasis)
lastYearNew <- lastYearNew$fd
lastYearmat <- eval.fd(c(0:80), lastYearNew)
# calculate integral of beta1(s,t)*x_i(t)
dim(Swede.beta1mat)
mat=load("/Users/raunaksandhu/Desktop/UNI/4th YR/Winter/MATH 518/RCode/Testing/Sweden.Rdata")
mat=as.matrix(SwedeMat)
matplot(mat,type="l")
SwedeMat = mat
dim(SwedeMat)
SwedeLogHazard = as.matrix(SwedeMat)
dimnames(SwedeLogHazard)[[2]] <- paste('b', 1751:1894, sep='')
Fig10.10data = cbind(SwedeLogHazard[, c('b1751', 'b1810', 'b1860')],
Swede1920)
SwedeTime = 0:80;
SwedeRng = c(0,80);
matplot(SwedeTime, Fig10.10data,
type='l',lwd=2,xlab='age',ylab='log Hazard',col=1,
cex.lab=1.5,cex.axis=1.5)
nbasis = 75
norder = 6
SwedeBasis = create.bspline.basis(SwedeRng, nbasis, norder)
D2fdPar = fdPar(SwedeBasis, lambda=1e-7)
SwedeLogHazfd = smooth.basis(SwedeTime, SwedeLogHazard, D2fdPar)$fd
nbasis     = 23
SwedeRng   = c(0,80)
SwedeBetaBasis = create.bspline.basis(SwedeRng,nbasis)
SwedeBeta0Par = fdPar(SwedeBetaBasis, 2, 1e-5)
SwedeBeta1fd  = bifd(matrix(0,23,23), SwedeBetaBasis, SwedeBetaBasis)
SwedeBeta1Par = bifdPar(SwedeBeta1fd, 2, 2, 1e3, 1e3)
SwedeBetaList = list(SwedeBeta0Par, SwedeBeta1Par)
NextYear = SwedeLogHazfd[2:144]
LastYear = SwedeLogHazfd[1:143]
Swede.linmod = linmod(NextYear, LastYear, SwedeBetaList)
Swede.ages = seq(0, 80, 1)
Swede.beta1mat = eval.bifd(Swede.ages, Swede.ages, Swede.linmod$beta1estbifd)
persp(Swede.ages, Swede.ages, Swede.beta1mat,
xlab="age", ylab="age",zlab="beta(s,t)",
cex.lab=1.5,cex.axis=1.5)
# predict next year
last_year = SwedeLogHazard[,144]
lastYearNew <- smooth.basis(c(0:80),last_year,SwedeBasis)
library(fda)
mat=load("/Users/raunaksandhu/Desktop/UNI/4th YR/Winter/MATH 518/RCode/Testing/Sweden.Rdata")
mat=as.matrix(SwedeMat)
matplot(mat,type="l")
SwedeMat = mat
dim(SwedeMat)
SwedeLogHazard = as.matrix(SwedeMat)
dimnames(SwedeLogHazard)[[2]] <- paste('b', 1751:1894, sep='')
Fig10.10data = cbind(SwedeLogHazard[, c('b1751', 'b1810', 'b1860')],
Swede1920)
SwedeTime = 0:80;
SwedeRng = c(0,80);
matplot(SwedeTime, Fig10.10data,
type='l',lwd=2,xlab='age',ylab='log Hazard',col=1,
cex.lab=1.5,cex.axis=1.5)
nbasis = 75
norder = 6
SwedeBasis = create.bspline.basis(SwedeRng, nbasis, norder)
D2fdPar = fdPar(SwedeBasis, lambda=1e-7)
SwedeLogHazfd = smooth.basis(SwedeTime, SwedeLogHazard, D2fdPar)$fd
nbasis     = 23
SwedeRng   = c(0,80)
quartz()
quartz()
quartz()
dev.new()
dev.new()
matplot(SwedeTime, Fig10.10data,
type='l',lwd=2,xlab='age',ylab='log Hazard',col=1,
cex.lab=1.5,cex.axis=1.5)
