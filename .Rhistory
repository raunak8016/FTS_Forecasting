# forecast for test dataset
prev_curve = EquityReturnsMat[,30]
for (i in 1:8) {
prev_curve_fd = smooth.basis(ReturnsDayTime, prev_curve, D2fdPar)$fd
plot.fd(prev_curve_fd)
f_integral_estimate <- inprod(b1_s,prev_curve_fd)
forecasted_test_years <- f_integral_estimate+beta0mat
matplot(TestingEquityReturnsMat[,i], type="l", ylim=c(-2,2), main=paste("Forecast", i))
lines(forecasted_test_years)
prev_curve = TestingEquityReturnsMat[,i]
}
for (i in 1:25) {
matplot(EquityReturnsMat[,i+1], type="l", ylim=c(-2,2), main=paste(i), col="blue")
lines(Forecasted_next_year[,i+1], col="green")
lines(Yhat_mat[,i], col="red")
}
for (i in 1:25) {
matplot(EquityReturnsMat[,i], type="l", ylim=c(-2,2), main=paste(i), col="blue")
lines(Forecasted_next_year[,i+1], col="green")
lines(Yhat_mat[,i], col="red")
}
for (i in 1:25) {
matplot(EquityReturnsMat[,i+1], type="l", ylim=c(-2,2), main=paste(i), col="blue")
lines(Forecasted_next_year[,i+1], col="green")
lines(Yhat_mat[,i], col="red")
}
for (i in 1:7) {
matplot(EquityReturnsMat[,i+1], type="l", ylim=c(-2,2), main=paste(i), col="blue")
lines(Forecasted_next_year[,i+1], col="green")
lines(Yhat_mat[,i], col="red")
}
for (i in 1:7) {
matplot(EquityReturnsMat[,i], type="l", ylim=c(-2,2), main=paste(i), col="blue")
lines(Forecasted_next_year[,i+1], col="green")
lines(Yhat_mat[,i], col="red")
}
for (i in 1:8) {
matplot(EquityReturnsMat[,i], type="l", ylim=c(-2,2), main=paste(i), col="blue")
lines(Forecasted_next_year[,i+1], col="green")
lines(Yhat_mat[,i], col="red")
}
for (i in 1:8) {
matplot(NextYear[,i], type="l", ylim=c(-2,2), main=paste(i), col="blue")
lines(Forecasted_next_year[,i+1], col="green")
lines(Yhat_mat[,i], col="red")
}
# data processing
vec = read.csv("ProcessedCSVData/PJME_prices.csv")
vec =as.vector(vec[,2])
prices_matrix = matrix(vec, nrow=24, ncol = 59)
dim(prices_matrix)
EquityReturnsMat = as.matrix(prices_matrix)
# training set
matplot(EquityReturnsMat[,1:50], type="l", xlab="Time (Hour)", ylab="Price")
# testing set
matplot(EquityReturnsMat[,51:58], type="l")
TestingEquityReturnsMat = EquityReturnsMat[,51:58]
EquityReturnsMat = EquityReturnsMat[,1:50]
matplot(EquityReturnsMat, type="l")
T_stationary(EquityReturnsMat)
# number of time points in a day (10 minute intervals over trading hours)
nbasis = 24
norder = 4
ReturnsDayTime = 0:23;
ReturnsDayRng = c(0,23);
ReturnsBasis = create.bspline.basis(ReturnsDayRng, nbasis, norder)
D2fdPar = fdPar(ReturnsBasis, lambda=0.1)
EquityReturnsMatfd = smooth.basis(ReturnsDayTime, EquityReturnsMat, D2fdPar)$fd
nbasis_regression = 24
ReturnsRng = c(0,23)
ReturnsBetaBasis = create.bspline.basis(ReturnsRng,nbasis_regression, norder=4)
ReturnsBeta0Par = fdPar(ReturnsBetaBasis, 2, 1e-10)
ReturnsBeta1fd  = bifd(matrix(0,24,24), ReturnsBetaBasis, ReturnsBetaBasis)
ReturnsBeta1Par = bifdPar(ReturnsBeta1fd, 2, 2, 1e3, 1e3)
ReturnsBetaList = list(ReturnsBeta0Par, ReturnsBeta1Par)
#  Define the response and explanatory vars
NextYear = EquityReturnsMatfd[2:ncol(EquityReturnsMat)] # X_(i+1)(t)
LastYear = EquityReturnsMatfd[1:(ncol(EquityReturnsMat)-1)] # X_i(t)
Returns.linmod = linmod(NextYear, LastYear, ReturnsBetaList)
Returns.times = seq(0, 23, 1)
Returns.beta1mat = eval.bifd(Returns.times, Returns.times, Returns.linmod$beta1estbifd)
persp(Returns.times, Returns.times, Returns.beta1mat,
xlab="time", ylab="time",zlab="beta(s,t)",
cex.lab=1.5,cex.axis=1.5)
Yhat_fd <- fd(Returns.linmod$yhatfdobj$coefs, Returns.linmod$yhatfdobj$basis)
plot.fd(Yhat_fd)
beta0mat = eval.fd(Returns.times, Returns.linmod$beta0estfd)
plot(beta0mat, type="l")
b1_s <- fd(Returns.linmod$beta1estbifd$coefs, Returns.linmod$beta1estbifd$sbasis)
b1_t <- fd(Returns.linmod$beta1estbifd$coefs, Returns.linmod$beta1estbifd$tbasis)
plot.fd(b1_s)
plot.fd(b1_t)
# checking forecasting setup
integral_estimate <- inprod(b1_s,LastYear)
Forecasted_next_year <- integral_estimate+beta0mat[1:24]
Yhat_mat <- eval.fd(Returns.times, Yhat_fd)
for (i in 1:25) {
matplot(EquityReturnsMat[,i+1], type="l", ylim=c(23000,50000), main=paste(i), col="blue")
lines(Forecasted_next_year[,i+1], col="green")
lines(Yhat_mat[,i], col="red")
}
# forecast for test dataset
prev_curve = EquityReturnsMat[,50]
for (i in 1:8) {
prev_curve_fd = smooth.basis(ReturnsDayTime, prev_curve, D2fdPar)$fd
plot.fd(prev_curve_fd)
f_integral_estimate <- inprod(b1_s,prev_curve_fd)
forecasted_test_years <- f_integral_estimate+beta0mat
matplot(TestingEquityReturnsMat[,i], type="l", ylim=c(10000,50000), main=paste("Forecast", i))
lines(forecasted_test_years)
prev_curve = TestingEquityReturnsMat[,i]
}
for (i in 1:55) {
matplot(EquityReturnsMat[,i+1], type="l", ylim=c(23000,50000), main=paste(i), col="blue")
lines(Forecasted_next_year[,i+1], col="green")
lines(Yhat_mat[,i], col="red")
}
for (i in 1:55) {
matplot(EquityReturnsMat[,i+1], type="l", ylim=c(23000,50000), main=paste(i), col="blue")
lines(Forecasted_next_year[,i+1], col="green")
lines(Yhat_mat[,i], col="red")
}
for (i in 1:5) {
matplot(EquityReturnsMat[,i+1], type="l", ylim=c(23000,50000), main=paste(i), col="blue")
lines(Forecasted_next_year[,i+1], col="green")
lines(Yhat_mat[,i], col="red")
}
for (i in 1:5) {
matplot(EquityReturnsMat[,i], type="l", ylim=c(23000,50000), main=paste(i), col="blue")
lines(Forecasted_next_year[,i+1], col="green")
lines(Yhat_mat[,i], col="red")
}
library(fda)
#provide directory of the RData
setwd("/Users/cao/Dropbox/Teaching/FDA/SummerCourse2018/R")
mat=load("Sweden.Rdata")
mat=as.matrix(SwedeMat)
quartz()
matplot(mat,type="l")
SwedeMat = mat
dim(SwedeMat)
SwedeLogHazard = as.matrix(SwedeMat)
dimnames(SwedeLogHazard)[[2]] <- paste('b', 1751:1894, sep='')
Fig10.10data = cbind(SwedeLogHazard[, c('b1751', 'b1810', 'b1860')],
Swede1920)
SwedeTime = 0:80;
SwedeRng = c(0,80);
quartz()
matplot(SwedeTime, Fig10.10data,
type='l',lwd=2,xlab='age',ylab='log Hazard',col=1,
cex.lab=1.5,cex.axis=1.5)
nbasis = 85
norder = 6
SwedeBasis = create.bspline.basis(SwedeRng, nbasis, norder)
D2fdPar = fdPar(SwedeBasis, lambda=1e-7)
SwedeLogHazfd = smooth.basis(SwedeTime, SwedeLogHazard, D2fdPar)$fd
nbasis     = 80
SwedeRng   = c(0,80)
SwedeBetaBasis = create.bspline.basis(SwedeRng,nbasis)
SwedeBeta0Par = fdPar(SwedeBetaBasis, 2, 1e-5)
SwedeBeta1fd  = bifd(matrix(0,80, 80), SwedeBetaBasis, SwedeBetaBasis)
SwedeBeta1Par = bifdPar(SwedeBeta1fd, 2, 2, 1e3, 1e3)
SwedeBetaList = list(SwedeBeta0Par, SwedeBeta1Par)
NextYear = SwedeLogHazfd[2:144]
LastYear = SwedeLogHazfd[1:143]
Swede.linmod = linmod(NextYear, LastYear, SwedeBetaList)
Swede.ages = seq(0, 80, 1)
Swede.beta1mat = eval.bifd(Swede.ages, Swede.ages, Swede.linmod$beta1estbifd)
quartz()
persp(Swede.ages, Swede.ages, Swede.beta1mat,
xlab="age", ylab="age",zlab="beta(s,t)",
cex.lab=1.5,cex.axis=1.5)
Wfd0 <- fd(Swede.linmod$yhatfdobj$coefs ,Swede.linmod$yhatfdobj$basis)
plot.fd(Wfd0)
Swede.beta0mat = eval.fd(Swede.ages, Swede.linmod$beta0estfd)
plot(Swede.beta0mat, type="l")
b1_s <- fd(Swede.linmod$beta1estbifd$coefs, Swede.linmod$beta1estbifd$sbasis)
b1_t <- fd(Swede.linmod$beta1estbifd$coefs, Swede.linmod$beta1estbifd$tbasis)
plot.fd(b1_s)
integral_estimate <- inprod(b1_s,LastYear)
b0_estimate <- eval.fd(seq(0, 80, 1), Swede.linmod$beta0estfd)
old_y <- integral_estimate+b0_estimate[1:80]
existing <- eval.fd(seq(0, 80, 1), Wfd0)
matplot(old_y[,50], type="l")
lines(mat[,50])
dev.off()
matplot(old_y[,50], type="l")
lines(mat[,50])
lines(existing[,50])
dev.new()
matplot(old_y[,50], type="l")
matplot(old_y[,50], type="l")
lines(mat[,50])
lines(existing[,50])
matplot(old_y[,50], type="l")
lines(mat[,51])
lines(existing[,50])
matplot(old_y[,1], type="l")
51
lines(mat[,51])
lines(existing[,50])
library(fda)
library(tidyverse)
# data processing
vec = read.csv("ProcessedCSVData/PJME_prices.csv")
vec =as.vector(vec[,2])
prices_matrix = matrix(vec, nrow=24, ncol = 59)
dim(prices_matrix)
EquityReturnsMat = as.matrix(prices_matrix)
# training set
matplot(EquityReturnsMat[,1:50], type="l", xlab="Time (Hour)", ylab="Price")
# testing set
matplot(EquityReturnsMat[,51:58], type="l")
TestingEquityReturnsMat = EquityReturnsMat[,51:58]
EquityReturnsMat = EquityReturnsMat[,1:50]
matplot(EquityReturnsMat, type="l")
T_stationary(EquityReturnsMat)
# number of time points in a day (10 minute intervals over trading hours)
nbasis = 24
norder = 4
ReturnsDayTime = 0:23;
ReturnsDayRng = c(0,23);
ReturnsBasis = create.bspline.basis(ReturnsDayRng, nbasis, norder)
D2fdPar = fdPar(ReturnsBasis, lambda=0.1)
EquityReturnsMatfd = smooth.basis(ReturnsDayTime, EquityReturnsMat, D2fdPar)$fd
nbasis_regression = 24
ReturnsRng = c(0,23)
ReturnsBetaBasis = create.bspline.basis(ReturnsRng,nbasis_regression, norder=4)
ReturnsBeta0Par = fdPar(ReturnsBetaBasis, 2, 1e-10)
ReturnsBeta1fd  = bifd(matrix(0,24,24), ReturnsBetaBasis, ReturnsBetaBasis)
ReturnsBeta1Par = bifdPar(ReturnsBeta1fd, 2, 2, 1e3, 1e3)
ReturnsBetaList = list(ReturnsBeta0Par, ReturnsBeta1Par)
#  Define the response and explanatory vars
NextYear = EquityReturnsMatfd[2:ncol(EquityReturnsMat)] # X_(i+1)(t)
LastYear = EquityReturnsMatfd[1:(ncol(EquityReturnsMat)-1)] # X_i(t)
Returns.linmod = linmod(NextYear, LastYear, ReturnsBetaList)
Returns.times = seq(0, 23, 1)
Returns.beta1mat = eval.bifd(Returns.times, Returns.times, Returns.linmod$beta1estbifd)
persp(Returns.times, Returns.times, Returns.beta1mat,
xlab="time", ylab="time",zlab="beta(s,t)",
cex.lab=1.5,cex.axis=1.5)
persp(Returns.times, Returns.times, Returns.beta1mat,
xlab="Time (h)", ylab="Time (h)",zlab="beta(s,t)",
cex.lab=1.5,cex.axis=1.5)
persp(Returns.times, Returns.times, Returns.beta1mat,
xlab="Time (h)", ylab="Time (h)",zlab="beta(s,t)",
cex.lab=1.5,cex.axis=2)
persp(Returns.times, Returns.times, Returns.beta1mat,
xlab="Time (h)", ylab="Time (h)",zlab="beta(s,t)",
cex.lab=1.5,cex.axis=2)
persp(Returns.times, Returns.times, Returns.beta1mat,
xlab="Time (h)", ylab="Time (h)",zlab="beta(s,t)",
cex.lab=2,cex.axis=2)
persp(Returns.times, Returns.times, Returns.beta1mat,
xlab="Time (h)", ylab="Time (h)",zlab="beta(s,t)",
cex.lab=1.5,cex.axis=2)
persp(Returns.times, Returns.times, Returns.beta1mat,
xlab="Time (h)", ylab="Time (h)",zlab="beta(s,t)",
cex.lab=1.5,cex.axis=1.5, )
persp(Returns.times, Returns.times, Returns.beta1mat,
xlab="Time (h)", ylab="Time (h)",zlab="beta(s,t)",
cex.lab=1.5,cex.axis=1.5, theta=30)
persp(Returns.times, Returns.times, Returns.beta1mat,
xlab="Time (h)", ylab="Time (h)",zlab="beta(s,t)",
cex.lab=1.5,cex.axis=1.5, theta=-30)
persp(Returns.times, Returns.times, Returns.beta1mat,
xlab="Time (h)", ylab="Time (h)",zlab="beta(s,t)",
cex.lab=1,cex.axis=1.5, theta=-30)
persp(Returns.times, Returns.times, Returns.beta1mat,
xlab="Time (h)", ylab="Time (h)",zlab="beta(s,t)",
cex.lab=1,cex.axis=1.5, theta=270)
persp(Returns.times, Returns.times, Returns.beta1mat,
xlab="Time (h)", ylab="Time (h)",zlab="beta(s,t)",
cex.lab=1,cex.axis=1.5, theta=360)
persp(Returns.times, Returns.times, Returns.beta1mat,
xlab="Time (h)", ylab="Time (h)",zlab="beta(s,t)",
cex.lab=1,cex.axis=1.5, theta=320)
persp(Returns.times, Returns.times, Returns.beta1mat,
xlab="Time (h)", ylab="Time (h)",zlab="beta(s,t)",
cex.lab=1,cex.axis=1.5, theta=-30)
persp(Returns.times, Returns.times, Returns.beta1mat,
xlab="Time (h)", ylab="Time (h)",zlab="beta(s,t)",
cex.lab=1,cex.axis=1.5, theta=-20)
beta0mat = eval.fd(Returns.times, Returns.linmod$beta0estfd)
plot(beta0mat, type="l")
plot(beta0mat, type="l", xlab="Time (h)", ylab="Price")
b1_s <- fd(Returns.linmod$beta1estbifd$coefs, Returns.linmod$beta1estbifd$sbasis)
b1_t <- fd(Returns.linmod$beta1estbifd$coefs, Returns.linmod$beta1estbifd$tbasis)
plot.fd(b1_s)
plot.fd(b1_t)
# checking forecasting setup
integral_estimate <- inprod(b1_s,LastYear)
Forecasted_next_year <- integral_estimate+beta0mat[1:24]
Yhat_mat <- eval.fd(Returns.times, Yhat_fd)
for (i in 1:5) {
matplot(EquityReturnsMat[,i], type="l", ylim=c(23000,50000), main=paste(i), col="blue")
lines(Forecasted_next_year[,i+1], col="green")
lines(Yhat_mat[,i], col="red")
}
# forecast for test dataset
prev_curve = EquityReturnsMat[,50]
par(2,4)
for (i in 1:8) {
prev_curve_fd = smooth.basis(ReturnsDayTime, prev_curve, D2fdPar)$fd
plot.fd(prev_curve_fd)
f_integral_estimate <- inprod(b1_s,prev_curve_fd)
forecasted_test_years <- f_integral_estimate+beta0mat
matplot(TestingEquityReturnsMat[,i], type="l", ylim=c(10000,50000), main=paste("Forecast", i))
lines(forecasted_test_years)
prev_curve = TestingEquityReturnsMat[,i]
}
par(mfrow= c(4,2))
for (i in 1:8) {
prev_curve_fd = smooth.basis(ReturnsDayTime, prev_curve, D2fdPar)$fd
plot.fd(prev_curve_fd)
f_integral_estimate <- inprod(b1_s,prev_curve_fd)
forecasted_test_years <- f_integral_estimate+beta0mat
matplot(TestingEquityReturnsMat[,i], type="l", ylim=c(10000,50000), main=paste("Forecast", i))
lines(forecasted_test_years)
prev_curve = TestingEquityReturnsMat[,i]
}
par(mfrow= c(2,4))
for (i in 1:8) {
prev_curve_fd = smooth.basis(ReturnsDayTime, prev_curve, D2fdPar)$fd
plot.fd(prev_curve_fd)
f_integral_estimate <- inprod(b1_s,prev_curve_fd)
forecasted_test_years <- f_integral_estimate+beta0mat
matplot(TestingEquityReturnsMat[,i], type="l", ylim=c(10000,50000), main=paste("Forecast", i))
lines(forecasted_test_years)
prev_curve = TestingEquityReturnsMat[,i]
}
# forecast for test dataset
prev_curve = EquityReturnsMat[,50]
par(mfrow= c(2,4))
for (i in 1:8) {
prev_curve_fd = smooth.basis(ReturnsDayTime, prev_curve, D2fdPar)$fd
f_integral_estimate <- inprod(b1_s,prev_curve_fd)
forecasted_test_years <- f_integral_estimate+beta0mat
matplot(TestingEquityReturnsMat[,i], type="l", ylim=c(10000,50000), main=paste("Forecast", i))
lines(forecasted_test_years)
prev_curve = TestingEquityReturnsMat[,i]
}
for (i in 1:8) {
prev_curve_fd = smooth.basis(ReturnsDayTime, prev_curve, D2fdPar)$fd
f_integral_estimate <- inprod(b1_s,prev_curve_fd)
forecasted_test_years <- f_integral_estimate+beta0mat
matplot(TestingEquityReturnsMat[,i], type="l", ylim=c(10000,50000), main=paste("Forecast", i))
lines(forecasted_test_years, col="red")
prev_curve = TestingEquityReturnsMat[,i]
}
# forecast for test dataset
prev_curve = EquityReturnsMat[,50]
par(mfrow= c(2,4))
for (i in 1:8) {
prev_curve_fd = smooth.basis(ReturnsDayTime, prev_curve, D2fdPar)$fd
f_integral_estimate <- inprod(b1_s,prev_curve_fd)
forecasted_test_years <- f_integral_estimate+beta0mat
matplot(TestingEquityReturnsMat[,i], type="l", ylim=c(10000,50000), main=paste("Forecast", i))
lines(forecasted_test_years, col="red")
prev_curve = TestingEquityReturnsMat[,i]
}
# forecast for test dataset
prev_curve = EquityReturnsMat[,50]
par(mfrow= c(2,4))
for (i in 1:8) {
prev_curve_fd = smooth.basis(ReturnsDayTime, prev_curve, D2fdPar)$fd
f_integral_estimate <- inprod(b1_s,prev_curve_fd)
forecasted_test_years <- f_integral_estimate+beta0mat
matplot(TestingEquityReturnsMat[,i], type="l", ylim=c(10000,50000), main=paste("Forecast", i))
lines(smooth.basis(forecasted_test_years, prev_curve, D2fdPar)$fd, col="red")
prev_curve = TestingEquityReturnsMat[,i]
}
plot.fd(smooth.basis(forecasted_test_years, prev_curve, D2fdPar)$fd, col="red", , ylim=c(10000,50000), main=paste("Forecast", i)))
lines(TestingEquityReturnsMat[,i)
# forecast for test dataset
prev_curve = EquityReturnsMat[,50]
par(mfrow= c(2,4))
for (i in 1:8) {
# forecast for test dataset
prev_curve = EquityReturnsMat[,50]
par(mfrow= c(2,4))
for (i in 1:8) {
# data processing
vec = read.csv("ProcessedCSVData/PJME_prices.csv")
vec =as.vector(vec[,2])
prices_matrix = matrix(vec, nrow=24, ncol = 59)
dim(prices_matrix)
EquityReturnsMat = as.matrix(prices_matrix)
# training set
matplot(EquityReturnsMat[,1:50], type="l", xlab="Time (Hour)", ylab="Price")
# testing set
matplot(EquityReturnsMat[,51:58], type="l")
TestingEquityReturnsMat = EquityReturnsMat[,51:58]
EquityReturnsMat = EquityReturnsMat[,1:50]
matplot(EquityReturnsMat, type="l")
T_stationary(EquityReturnsMat)
# number of time points in a day (10 minute intervals over trading hours)
nbasis = 24
norder = 4
ReturnsDayTime = 0:23;
ReturnsDayRng = c(0,23);
ReturnsBasis = create.bspline.basis(ReturnsDayRng, nbasis, norder)
D2fdPar = fdPar(ReturnsBasis, lambda=0.1)
EquityReturnsMatfd = smooth.basis(ReturnsDayTime, EquityReturnsMat, D2fdPar)$fd
nbasis_regression = 24
ReturnsRng = c(0,23)
ReturnsBetaBasis = create.bspline.basis(ReturnsRng,nbasis_regression, norder=4)
ReturnsBeta0Par = fdPar(ReturnsBetaBasis, 2, 1e-10)
ReturnsBeta1fd  = bifd(matrix(0,24,24), ReturnsBetaBasis, ReturnsBetaBasis)
ReturnsBeta1Par = bifdPar(ReturnsBeta1fd, 2, 2, 1e3, 1e3)
ReturnsBetaList = list(ReturnsBeta0Par, ReturnsBeta1Par)
#  Define the response and explanatory vars
NextYear = EquityReturnsMatfd[2:ncol(EquityReturnsMat)] # X_(i+1)(t)
LastYear = EquityReturnsMatfd[1:(ncol(EquityReturnsMat)-1)] # X_i(t)
Returns.linmod = linmod(NextYear, LastYear, ReturnsBetaList)
Returns.times = seq(0, 23, 1)
Returns.beta1mat = eval.bifd(Returns.times, Returns.times, Returns.linmod$beta1estbifd)
persp(Returns.times, Returns.times, Returns.beta1mat,
xlab="Time (h)", ylab="Time (h)",zlab="beta(s,t)",
cex.lab=1,cex.axis=1.5, theta=-20)
Yhat_fd <- fd(Returns.linmod$yhatfdobj$coefs, Returns.linmod$yhatfdobj$basis)
plot.fd(Yhat_fd)
beta0mat = eval.fd(Returns.times, Returns.linmod$beta0estfd)
plot(beta0mat, type="l", xlab="Time (h)", ylab="Price")
b1_s <- fd(Returns.linmod$beta1estbifd$coefs, Returns.linmod$beta1estbifd$sbasis)
b1_t <- fd(Returns.linmod$beta1estbifd$coefs, Returns.linmod$beta1estbifd$tbasis)
plot.fd(b1_s)
plot.fd(b1_t)
# checking forecasting setup
integral_estimate <- inprod(b1_s,LastYear)
Forecasted_next_year <- integral_estimate+beta0mat[1:24]
Yhat_mat <- eval.fd(Returns.times, Yhat_fd)
for (i in 1:5) {
matplot(EquityReturnsMat[,i], type="l", ylim=c(23000,50000), main=paste(i), col="blue")
lines(Forecasted_next_year[,i+1], col="green")
lines(Yhat_mat[,i], col="red")
}
# forecast for test dataset
prev_curve = EquityReturnsMat[,50]
par(mfrow= c(2,4))
for (i in 1:8) {
# forecast for test dataset
prev_curve = EquityReturnsMat[,50]
par(mfrow= c(2,4))
for (i in 1:8) {
prev_curve_fd = smooth.basis(ReturnsDayTime, prev_curve, D2fdPar)$fd
f_integral_estimate <- inprod(b1_s,prev_curve_fd)
forecasted_test_years <- f_integral_estimate+beta0mat
plot.fd(smooth.basis(ReturnsDayTime, forecasted_test_years, D2fdPar)$fd, col="red", ylim=c(10000,50000), main=paste("Forecast", i))
lines(TestingEquityReturnsMat[,i])
prev_curve = TestingEquityReturnsMat[,i]
}
# forecast for test dataset
prev_curve = EquityReturnsMat[,50]
par(mfrow= c(2,4))
for (i in 1:8) {
prev_curve_fd = smooth.basis(ReturnsDayTime, prev_curve, D2fdPar)$fd
f_integral_estimate <- inprod(b1_s,prev_curve_fd)
forecasted_test_years <- f_integral_estimate+beta0mat
plot.fd(smooth.basis(ReturnsDayTime, forecasted_test_years, D2fdPar)$fd, col="red", ylim=c(10000,50000), main=paste("Forecast", i))
lines(TestingEquityReturnsMat[,i])
prev_curve = TestingEquityReturnsMat[,i]
}
dev.new()
for (i in 1:8) {
prev_curve_fd = smooth.basis(ReturnsDayTime, prev_curve, D2fdPar)$fd
f_integral_estimate <- inprod(b1_s,prev_curve_fd)
forecasted_test_years <- f_integral_estimate+beta0mat
plot.fd(smooth.basis(ReturnsDayTime, forecasted_test_years, D2fdPar)$fd, col="red", ylim=c(10000,50000), main=paste("Forecast", i))
lines(TestingEquityReturnsMat[,i])
prev_curve = TestingEquityReturnsMat[,i]
}
dev.off()
for (i in 1:8) {
prev_curve_fd = smooth.basis(ReturnsDayTime, prev_curve, D2fdPar)$fd
f_integral_estimate <- inprod(b1_s,prev_curve_fd)
forecasted_test_years <- f_integral_estimate+beta0mat
plot.fd(smooth.basis(ReturnsDayTime, forecasted_test_years, D2fdPar)$fd, col="red", ylim=c(10000,50000), main=paste("Forecast", i))
lines(TestingEquityReturnsMat[,i])
prev_curve = TestingEquityReturnsMat[,i]
}
par(mfrow= c(2,4))
for (i in 1:8) {
prev_curve_fd = smooth.basis(ReturnsDayTime, prev_curve, D2fdPar)$fd
f_integral_estimate <- inprod(b1_s,prev_curve_fd)
forecasted_test_years <- f_integral_estimate+beta0mat
plot.fd(smooth.basis(ReturnsDayTime, forecasted_test_years, D2fdPar)$fd, col="red", ylim=c(10000,50000), main=paste("Forecast", i))
lines(TestingEquityReturnsMat[,i])
prev_curve = TestingEquityReturnsMat[,i]
}
for (i in 1:5) {
matplot(EquityReturnsMat[,i], type="l", ylim=c(23000,50000), main=paste(i), col="blue")
lines(Forecasted_next_year[,i+1], col="green")
lines(Yhat_mat[,i], col="red")
}
quartz()
for (i in 1:5) {
matplot(EquityReturnsMat[,i], type="l", ylim=c(23000,50000), main=paste(i), col="blue")
lines(Forecasted_next_year[,i+1], col="green")
lines(Yhat_mat[,i], col="red")
}
# forecast for test dataset
prev_curve = EquityReturnsMat[,50]
par(mfrow= c(2,4))
for (i in 1:8) {
prev_curve_fd = smooth.basis(ReturnsDayTime, prev_curve, D2fdPar)$fd
f_integral_estimate <- inprod(b1_s,prev_curve_fd)
forecasted_test_years <- f_integral_estimate+beta0mat
plot.fd(smooth.basis(ReturnsDayTime, forecasted_test_years, D2fdPar)$fd, col="red", ylim=c(10000,50000), main=paste("Forecast", i))
lines(TestingEquityReturnsMat[,i])
prev_curve = TestingEquityReturnsMat[,i]
}
