library("fda")
library("ftsa")
library("rainbow")
setwd("/Users/raunaksandhu/Desktop/UNI/4th YR/Winter/MATH 518/FTS_Forecasting")
vec = read.csv("ProcessedCSVData/electricity_prices.csv")
vec =as.vector(vec[,3])
returns_matrix = matrix(vec, nrow=24, ncol = 59)
matplot(returns_matrix, type="l", xlab="Hour", ylab="Price")
returns_matrix_test = returns_matrix[,51:58]
returns_matrix = returns_matrix[,1:50]
matplot(returns_matrix, type="l")
matplot(returns_matrix_test, type="l")
nbasis = 24
norder = 4
ReturnsDayTime = 0:23;
ReturnsDayRng = c(0,23);
ReturnsBasis = create.bspline.basis(ReturnsDayRng, nbasis, norder)
D2fdPar = fdPar(ReturnsBasis, lambda=0.1)
EquityReturnsMatfd = smooth.basis(ReturnsDayTime, returns_matrix, D2fdPar)$fd
plot.fd(EquityReturnsMatfd, xlab = "Hour", ylab="Price")
returns_matrix = eval.fd(c(0:23), EquityReturnsMatfd)
matplot(returns_matrix, type="l")
EquityReturnsMatTestfd = smooth.basis(ReturnsDayTime, returns_matrix_test, D2fdPar)$fd
par(mfrow=c(1,2))
plot.fd(EquityReturnsMatfd, xlab = "Hour", ylab="Price", main="Train")
plot.fd(EquityReturnsMatTestfd, xlab = "Hour", ylab="Price", main="Test")
colnames(returns_matrix) <- c(1:50)
colnames(returns_matrix) <- c(1:50)
fts_returns = fts(c(1:24), returns_matrix, xname="Time", yname="Price")
fit = ftsm(y = fts_returns, order=6)
forecast = forecast(fit,h=8, method="arima")
plot(forecast, "components")
pred = forecast$mean$y
# plotting fit
temp = fit$coeff %*% t(fit$basis)
plot(temp[1,],type='l')
lines(returns_matrix[,1], col='red')
plot(temp[3,],type='l')
lines(returns_matrix[,3],col='red')
# plotting pred
quartz()
error_by_curve = matrix(nrow=2, ncol = 8)
# MAE
mean(abs(pred-returns_matrix_test))
# MAPE
mean(abs(pred-returns_matrix_test)/returns_matrix_test)
# MAE
mean(abs(pred-mean.fd(EquityReturnsMatfd)))
ff <- eval.fd(c(0:23), mean.fd(EquityReturnsMatfd))
mean(abs(ff-mean.fd(EquityReturnsMatfd)))
plot(ff)
mean(abs(ff-returns_matrix_test))
m = matrix(nrow = 24, ncol = 8)
for (i in ncol(m)) {
m[,i]=ff
}
mean(abs(ff-returns_matrix_test))
View(m)
for (i in 1:ncol(m)) {
m[,i]=ff
}
mean(abs(ff-returns_matrix_test))
View(m)
mean(abs(m-returns_matrix_test))
mean((m-returns_matrix_test)^2)
library(fda)
library(tidyverse)
# data processing
vec = read.csv("ProcessedCSVData/electricity_prices.csv")
vec =as.vector(vec[,3])
prices_matrix = matrix(vec, nrow=24, ncol = 59)
dim(prices_matrix)
EquityReturnsMat = as.matrix(prices_matrix)
# number of time points in a day (10 minute intervals over trading hours)
nbasis = 24
norder = 4
ReturnsDayTime = 0:23;
ReturnsDayRng = c(0,23);
ReturnsBasis = create.bspline.basis(ReturnsDayRng, nbasis, norder)
D2fdPar = fdPar(ReturnsBasis, lambda=0.1)
EquityReturnsMatfd = smooth.basis(ReturnsDayTime, EquityReturnsMat, D2fdPar)$fd
returns_matrix = eval.fd(c(0:23), EquityReturnsMatfd)
matplot(returns_matrix, type="l")
plot.fd(returns_matrix)
plot.fd(EquityReturnsMatfd)
plot.fd(EquityReturnsMatfd, xlab="Hour", ylab="Price")
# mat =load("ProcessedRData/2020_SPY_cidr_2020-06-15_2020-08-11_matrix.RData")
mat =load("ProcessedRData/2020_SPY_cidr_2020-07-06_2020-09-02_matrix.RData")
mat =as.matrix(returns_matrix)
matplot(returns_matrix, type="l")
equity_returns_matrix_name = "2020_SPY_cidr_2020-07-06_2020-09-02_matrix"
# data processing
mat =load(paste("ProcessedRData/", equity_returns_matrix_name, ".RData", sep=""))
mat=as.matrix(returns_matrix)
dim(returns_matrix)
EquityReturnsMat = as.matrix(returns_matrix)
# training set
matplot(EquityReturnsMat[,1:38], type="l", xlab="Time (15*x min)", ylab="CIDR (%)")
# training set
matplot(EquityReturnsMat[,1:38], type="l", xlab="Time (10*x min)", ylab="CIDR (%)")
